# ‡πÅ‡∏ú‡∏ô‡∏Å‡∏≤‡∏£‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ñ‡πà‡∏≤‡∏ö‡∏£‡∏¥‡∏Å‡∏≤‡∏£ (SlipOK Payment System)

## 1. ‡∏†‡∏≤‡∏û‡∏£‡∏ß‡∏°‡πÇ‡∏Ñ‡∏£‡∏á‡∏Å‡∏≤‡∏£

### 1.1 ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏õ‡∏£‡∏∞‡∏™‡∏á‡∏Ñ‡πå
‡∏û‡∏±‡∏í‡∏ô‡∏≤‡∏£‡∏∞‡∏ö‡∏ö‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ñ‡πà‡∏≤ subscription ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Blood Pressure Monitor Platform ‡πÇ‡∏î‡∏¢‡πÉ‡∏ä‡πâ SlipOK API ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≤‡∏Å‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£‡πÑ‡∏ó‡∏¢

### 1.2 ‡∏Ç‡πâ‡∏≠‡∏Å‡∏≥‡∏´‡∏ô‡∏î
| ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ | ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î |
|--------|-----------|
| ‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏≤‡∏á‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô | Web Application + Telegram Bot |
| ‡∏ß‡∏¥‡∏ò‡∏µ‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞ | ‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏ú‡πà‡∏≤‡∏ô‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£ ‚Üí ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏•‡∏¥‡∏õ ‚Üí ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥ |
| ‡∏£‡∏≤‡∏Ñ‡∏≤ Monthly | 9 ‡∏ö‡∏≤‡∏ó (30 ‡∏ß‡∏±‡∏ô) |
| ‡∏£‡∏≤‡∏Ñ‡∏≤ Yearly | 99 ‡∏ö‡∏≤‡∏ó (365 ‡∏ß‡∏±‡∏ô) |
| ‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö | ‡πÉ‡∏ä‡πâ SlipOK API ‡∏û‡∏£‡πâ‡∏≠‡∏° `log:true` (‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥ + ‡∏ï‡∏£‡∏ß‡∏à‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö) |

### 1.3 ‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå Premium
| Feature | Free | Premium |
|---------|------|---------|
| ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô BP records | ‡∏à‡∏≥‡∏Å‡∏±‡∏î 30 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ | ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î |
| ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£ export | 30 ‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î | ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î |
| ‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏≤‡∏ü | 30 ‡∏ß‡∏±‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î | ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î |

---

## 2. SlipOK API Reference

### 2.1 Check Slip API
```
POST https://api.slipok.com/api/line/apikey/{BRANCH_ID}
Header: x-authorization: {API_KEY}
```

### 2.2 Request Body Options
| Parameter | Type | Description |
|-----------|------|-------------|
| `files` | File/Base64 | ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ (JPG, PNG, WEBP) |
| `data` | String | QR Code data ‡∏à‡∏≤‡∏Å‡∏™‡∏•‡∏¥‡∏õ |
| `url` | String | URL ‡∏Ç‡∏≠‡∏á‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏™‡∏•‡∏¥‡∏õ |
| `log` | Boolean | `true` = ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• + ‡∏ï‡∏£‡∏ß‡∏à‡∏ã‡πâ‡∏≥ + ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ |
| `amount` | Number | ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á (optional) |

### 2.3 Response Data (Success)
```json
{
  "success": true,
  "data": {
    "transRef": "010092101507665143",
    "amount": 9.0,
    "sendingBank": "004",
    "receivingBank": "006",
    "transDate": "20260113",
    "transTime": "10:15:07",
    "sender": {
      "displayName": "‡∏ô‡∏≤‡∏¢ ‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á ‡∏Å",
      "account": { "value": "xxx-x-x1234-x" }
    },
    "receiver": {
      "displayName": "‡∏£‡πâ‡∏≤‡∏ô‡∏Ñ‡πâ‡∏≤",
      "account": { "value": "xxx-x-x5678-x" }
    }
  }
}
```

### 2.4 Error Codes
| Code | ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏´‡∏°‡∏≤‡∏¢ | User Message |
|------|----------|--------------|
| 1006 | ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á | ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏™‡∏•‡∏¥‡∏õ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô |
| 1007 | ‡πÑ‡∏°‡πà‡∏û‡∏ö QR Code | ‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏°‡∏µ QR Code ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö |
| 1008 | QR ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏•‡∏¥‡∏õ‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô | QR Code ‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏•‡∏¥‡∏õ‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô |
| 1011 | QR ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏ | ‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£ |
| 1012 | ‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥ | ‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏ä‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß |
| 1013 | ‡∏¢‡∏≠‡∏î‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á | ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏û‡∏•‡∏ô |
| 1014 | ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á | ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏ |

---

## 3. Database Schema

### 3.1 Payment Model (‡πÉ‡∏´‡∏°‡πà)
```python
# app/models.py

class Payment(Base):
    """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏Ñ‡πà‡∏≤ subscription"""
    __tablename__ = "payments"

    # Primary Key
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    # SlipOK Verification Data
    trans_ref = Column(String(50), nullable=False)           # Transaction reference ‡∏à‡∏≤‡∏Å SlipOK
    trans_ref_hash = Column(String(64), unique=True, index=True)  # Hash ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏ã‡πâ‡∏≥

    # Transaction Details
    amount = Column(Float, nullable=False)                   # ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ
    sending_bank = Column(String(10), nullable=True)         # ‡∏£‡∏´‡∏±‡∏™‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£‡∏ú‡∏π‡πâ‡πÇ‡∏≠‡∏ô
    sender_name_encrypted = Column(String, nullable=True)    # ‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡πÇ‡∏≠‡∏ô (encrypted)
    receiver_name = Column(String(100), nullable=True)       # ‡∏ä‡∏∑‡πà‡∏≠‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö
    trans_date = Column(String(10), nullable=True)           # ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏≠‡∏ô (yyyyMMdd)
    trans_time = Column(String(10), nullable=True)           # ‡πÄ‡∏ß‡∏•‡∏≤‡πÇ‡∏≠‡∏ô (HH:mm:ss)

    # Subscription Info
    plan_type = Column(String(20), nullable=False)           # "monthly" ‡∏´‡∏£‡∏∑‡∏≠ "yearly"
    plan_amount = Column(Float, nullable=False)              # ‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏û‡∏•‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å

    # Status
    status = Column(String(20), default="pending")           # pending, verified, failed
    error_code = Column(String(20), nullable=True)           # SlipOK error code
    error_message = Column(String(255), nullable=True)       # Error message
    verification_response = Column(Text, nullable=True)      # Full JSON response

    # Timestamps
    created_at = Column(DateTime, default=now_th)
    verified_at = Column(DateTime, nullable=True)

    # Relationships
    user = relationship("User", back_populates="payments")
```

### 3.2 User Model (‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç)
```python
# ‡πÄ‡∏û‡∏¥‡πà‡∏° relationship ‡πÉ‡∏ô User model
payments = relationship("Payment", back_populates="user")
```

---

## 4. Backend Implementation

### 4.1 ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà: `app/config/pricing.py`
```python
"""Subscription pricing configuration"""
from typing import Dict

SUBSCRIPTION_PLANS: Dict[str, dict] = {
    "monthly": {
        "name": "Premium ‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô",
        "name_en": "Premium Monthly",
        "price": 9.0,
        "duration_days": 30,
        "features": [
            "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î",
            "‡∏î‡∏π‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
            "Export ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î"
        ]
    },
    "yearly": {
        "name": "Premium ‡∏£‡∏≤‡∏¢‡∏õ‡∏µ",
        "name_en": "Premium Yearly",
        "price": 99.0,
        "duration_days": 365,
        "features": [
            "‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î",
            "‡∏î‡∏π‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î",
            "Export ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î",
            "‡∏õ‡∏£‡∏∞‡∏´‡∏¢‡∏±‡∏î 8 ‡∏ö‡∏≤‡∏ó (‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏¢‡πÄ‡∏î‡∏∑‡∏≠‡∏ô)"
        ]
    }
}

# ‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô (‡πÅ‡∏™‡∏î‡∏á‡πÉ‡∏´‡πâ user)
PAYMENT_ACCOUNT = {
    "bank": "‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£‡∏Å‡∏™‡∏¥‡∏Å‡∏£‡πÑ‡∏ó‡∏¢",
    "bank_code": "004",
    "account_number": "xxx-x-xxxxx-x",  # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á
    "account_name": "‡∏ä‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ"          # ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÄ‡∏≠‡∏á
}

AMOUNT_TOLERANCE = 0.50  # ‡∏¢‡∏≠‡∏°‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏•‡∏≤‡∏î‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô 0.50 ‡∏ö‡∏≤‡∏ó

def get_plan(plan_type: str) -> dict:
    return SUBSCRIPTION_PLANS.get(plan_type)

def is_valid_amount(expected: float, actual: float) -> bool:
    return abs(expected - actual) <= AMOUNT_TOLERANCE
```

### 4.2 ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà: `app/services/slipok.py`
```python
"""SlipOK API Integration Service"""
import os
import requests
import logging
from typing import Optional
from dataclasses import dataclass

logger = logging.getLogger(__name__)

SLIPOK_API_KEY = os.getenv("SLIPOK_API_KEY")
SLIPOK_BRANCH_ID = os.getenv("SLIPOK_BRANCH_ID", "1")
SLIPOK_BASE_URL = "https://api.slipok.com/api/line/apikey"

@dataclass
class SlipVerificationResult:
    """‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ"""
    success: bool
    trans_ref: Optional[str] = None
    amount: Optional[float] = None
    sending_bank: Optional[str] = None
    sender_name: Optional[str] = None
    receiver_name: Optional[str] = None
    trans_date: Optional[str] = None
    trans_time: Optional[str] = None
    error_code: Optional[str] = None
    error_message: Optional[str] = None
    raw_response: Optional[dict] = None


class SlipOKService:
    """Service ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏ú‡πà‡∏≤‡∏ô SlipOK API"""

    ERROR_MESSAGES = {
        "1006": "‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏£‡∏π‡∏õ‡∏™‡∏•‡∏¥‡∏õ‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô",
        "1007": "‡πÑ‡∏°‡πà‡∏û‡∏ö QR Code ‡πÉ‡∏ô‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û",
        "1008": "QR Code ‡∏ô‡∏µ‡πâ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πà‡∏™‡∏•‡∏¥‡∏õ‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô",
        "1011": "‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£",
        "1012": "‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏ä‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß",
        "1013": "‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏û‡∏•‡∏ô",
        "1014": "‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÇ‡∏≠‡∏ô‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏"
    }

    def __init__(self):
        if not SLIPOK_API_KEY:
            raise ValueError("SLIPOK_API_KEY not configured")
        self.api_key = SLIPOK_API_KEY
        self.branch_id = SLIPOK_BRANCH_ID
        self.url = f"{SLIPOK_BASE_URL}/{self.branch_id}"

    def verify_slip_image(
        self,
        image_content: bytes,
        expected_amount: Optional[float] = None
    ) -> SlipVerificationResult:
        """
        ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏à‡∏≤‡∏Å‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û

        Args:
            image_content: Binary image data
            expected_amount: ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏ó‡∏µ‡πà‡∏Ñ‡∏≤‡∏î‡∏´‡∏ß‡∏±‡∏á (optional)
        """
        headers = {"x-authorization": self.api_key}
        files = {"files": ("slip.jpg", image_content, "image/jpeg")}
        data = {"log": "true"}

        if expected_amount:
            data["amount"] = str(expected_amount)

        try:
            response = requests.post(
                self.url,
                headers=headers,
                files=files,
                data=data,
                timeout=30
            )
            result = response.json()

            if result.get("success") and result.get("data", {}).get("success"):
                slip_data = result["data"]
                sender = slip_data.get("sender", {})
                receiver = slip_data.get("receiver", {})

                return SlipVerificationResult(
                    success=True,
                    trans_ref=slip_data.get("transRef"),
                    amount=float(slip_data.get("amount", 0)),
                    sending_bank=slip_data.get("sendingBank"),
                    sender_name=sender.get("displayName"),
                    receiver_name=receiver.get("displayName"),
                    trans_date=slip_data.get("transDate"),
                    trans_time=slip_data.get("transTime"),
                    raw_response=result
                )
            else:
                error_code = str(result.get("code", ""))
                return SlipVerificationResult(
                    success=False,
                    error_code=error_code,
                    error_message=self.ERROR_MESSAGES.get(error_code, result.get("message", "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")),
                    raw_response=result
                )

        except requests.Timeout:
            return SlipVerificationResult(
                success=False,
                error_code="TIMEOUT",
                error_message="‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏ï‡∏≠‡∏ö‡∏™‡∏ô‡∏≠‡∏á ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"
            )
        except Exception as e:
            logger.error(f"SlipOK API error: {e}")
            return SlipVerificationResult(
                success=False,
                error_code="ERROR",
                error_message="‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà"
            )

    def check_quota(self) -> dict:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö quota ‡∏Ñ‡∏á‡πÄ‡∏´‡∏•‡∏∑‡∏≠"""
        headers = {"x-authorization": self.api_key}
        try:
            response = requests.get(
                f"{self.url}/quota",
                headers=headers,
                timeout=10
            )
            return response.json()
        except Exception as e:
            logger.error(f"Check quota error: {e}")
            return {"success": False, "error": str(e)}


# Singleton instance
slipok_service = SlipOKService() if SLIPOK_API_KEY else None
```

### 4.3 ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà: `app/routers/payment.py`
```python
"""Payment API Router"""
import logging
import uuid
import json
from datetime import timedelta
from fastapi import APIRouter, HTTPException, Depends, UploadFile, File, Form
from sqlalchemy.orm import Session

from ..database import get_db
from ..models import User, Payment
from ..schemas import StandardResponse
from ..utils.security import verify_api_key, get_current_user, now_th
from ..utils.encryption import encrypt_value, hash_value
from ..services.slipok import slipok_service
from ..config.pricing import SUBSCRIPTION_PLANS, PAYMENT_ACCOUNT, get_plan, is_valid_amount

router = APIRouter(prefix="/api/v1/payment", tags=["payment"])
logger = logging.getLogger(__name__)


@router.get("/plans")
async def get_subscription_plans(
    current_user: User = Depends(get_current_user),
    api_key: str = Depends(verify_api_key)
):
    """‡∏î‡∏π‡πÅ‡∏û‡∏•‡∏ô subscription ‡πÅ‡∏•‡∏∞‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
    plans = [{"plan_type": k, **v} for k, v in SUBSCRIPTION_PLANS.items()]

    return StandardResponse(
        status="success",
        message="Subscription plans retrieved",
        data={
            "plans": plans,
            "payment_account": PAYMENT_ACCOUNT,
            "current_tier": current_user.subscription_tier,
            "expires_at": str(current_user.subscription_expires_at) if current_user.subscription_expires_at else None
        }
    )


@router.post("/verify-slip")
async def verify_payment_slip(
    plan_type: str = Form(...),
    file: UploadFile = File(...),
    current_user: User = Depends(get_current_user),
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô"""

    # Validate plan
    plan = get_plan(plan_type)
    if not plan:
        raise HTTPException(status_code=400, detail="‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")

    # Check SlipOK service
    if not slipok_service:
        raise HTTPException(status_code=503, detail="‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")

    # Validate file
    if not file.content_type or not file.content_type.startswith("image/"):
        raise HTTPException(status_code=400, detail="‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û")

    content = await file.read()
    if len(content) > 10 * 1024 * 1024:  # 10MB
        raise HTTPException(status_code=413, detail="‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏ç‡πà‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ (‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î 10MB)")

    # Verify with SlipOK
    expected_amount = plan["price"]
    result = slipok_service.verify_slip_image(content, expected_amount)

    if not result.success:
        # Log failed attempt
        payment = Payment(
            user_id=current_user.id,
            trans_ref=f"FAILED-{uuid.uuid4()}",
            trans_ref_hash=hash_value(f"FAILED-{uuid.uuid4()}-{now_th()}"),
            amount=0,
            plan_type=plan_type,
            plan_amount=expected_amount,
            status="failed",
            error_code=result.error_code,
            error_message=result.error_message,
            verification_response=json.dumps(result.raw_response) if result.raw_response else None
        )
        db.add(payment)
        db.commit()

        raise HTTPException(status_code=400, detail=result.error_message)

    # Check duplicate trans_ref in our DB
    trans_ref_hash = hash_value(result.trans_ref)
    existing = db.query(Payment).filter(
        Payment.trans_ref_hash == trans_ref_hash,
        Payment.status == "verified"
    ).first()

    if existing:
        raise HTTPException(status_code=409, detail="‡∏™‡∏•‡∏¥‡∏õ‡∏ô‡∏µ‡πâ‡πÄ‡∏Ñ‡∏¢‡πÉ‡∏ä‡πâ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÅ‡∏•‡πâ‡∏ß")

    # Verify amount
    if not is_valid_amount(expected_amount, result.amount):
        raise HTTPException(
            status_code=400,
            detail=f"‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô ({result.amount} ‡∏ö‡∏≤‡∏ó) ‡πÑ‡∏°‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏£‡∏≤‡∏Ñ‡∏≤‡πÅ‡∏û‡∏•‡∏ô ({expected_amount} ‡∏ö‡∏≤‡∏ó)"
        )

    # Create payment record
    payment = Payment(
        user_id=current_user.id,
        trans_ref=result.trans_ref,
        trans_ref_hash=trans_ref_hash,
        amount=result.amount,
        sending_bank=result.sending_bank,
        sender_name_encrypted=encrypt_value(result.sender_name) if result.sender_name else None,
        receiver_name=result.receiver_name,
        trans_date=result.trans_date,
        trans_time=result.trans_time,
        plan_type=plan_type,
        plan_amount=expected_amount,
        status="verified",
        verification_response=json.dumps(result.raw_response),
        verified_at=now_th()
    )
    db.add(payment)

    # Upgrade subscription
    duration_days = plan["duration_days"]
    if (current_user.subscription_tier == "premium" and
        current_user.subscription_expires_at and
        current_user.subscription_expires_at > now_th()):
        new_expiry = current_user.subscription_expires_at + timedelta(days=duration_days)
    else:
        new_expiry = now_th() + timedelta(days=duration_days)

    current_user.subscription_tier = "premium"
    current_user.subscription_expires_at = new_expiry
    current_user.updated_at = now_th()

    db.commit()

    logger.info(f"Payment verified: user={current_user.id}, trans_ref={result.trans_ref}, plan={plan_type}")

    return StandardResponse(
        status="success",
        message="‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à! ‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Premium ‡πÅ‡∏•‡πâ‡∏ß",
        data={
            "payment_id": payment.id,
            "plan": plan_type,
            "amount": result.amount,
            "subscription_tier": "premium",
            "subscription_expires_at": str(new_expiry),
            "trans_ref": result.trans_ref
        }
    )


@router.get("/history")
async def get_payment_history(
    current_user: User = Depends(get_current_user),
    api_key: str = Depends(verify_api_key),
    db: Session = Depends(get_db)
):
    """‡∏î‡∏π‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô"""
    payments = db.query(Payment).filter(
        Payment.user_id == current_user.id
    ).order_by(Payment.created_at.desc()).limit(50).all()

    history = [{
        "id": p.id,
        "plan_type": p.plan_type,
        "amount": p.amount,
        "status": p.status,
        "trans_date": p.trans_date,
        "created_at": str(p.created_at),
        "verified_at": str(p.verified_at) if p.verified_at else None
    } for p in payments]

    return StandardResponse(
        status="success",
        message="Payment history retrieved",
        data={"payments": history}
    )


@router.get("/status")
async def get_subscription_status(
    current_user: User = Depends(get_current_user),
    api_key: str = Depends(verify_api_key)
):
    """‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ subscription ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
    is_active = False
    days_remaining = 0

    if current_user.subscription_tier == "premium" and current_user.subscription_expires_at:
        if current_user.subscription_expires_at > now_th():
            is_active = True
            days_remaining = (current_user.subscription_expires_at - now_th()).days

    return StandardResponse(
        status="success",
        message="Subscription status retrieved",
        data={
            "tier": current_user.subscription_tier,
            "is_active": is_active,
            "expires_at": str(current_user.subscription_expires_at) if current_user.subscription_expires_at else None,
            "days_remaining": days_remaining,
            "features": {
                "max_records": "unlimited" if is_active else 30,
                "history_days": "unlimited" if is_active else 30
            }
        }
    )
```

### 4.4 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: `app/main.py`
```python
# ‡πÄ‡∏û‡∏¥‡πà‡∏° import
from .routers import auth, users, bp_records, ocr, doctor, export, payment

# ‡πÄ‡∏û‡∏¥‡πà‡∏° router
app.include_router(payment.router)
```

---

## 5. Telegram Bot Implementation

### 5.1 ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà: `app/bot/handlers/payment.py`
```python
"""Telegram Payment Handler"""
import logging
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    ContextTypes, ConversationHandler, CommandHandler,
    MessageHandler, CallbackQueryHandler, filters
)

from ..services import get_user_by_telegram_id, verify_slip_payment, get_subscription_status
from ...config.pricing import SUBSCRIPTION_PLANS, PAYMENT_ACCOUNT

logger = logging.getLogger(__name__)

# Conversation states
WAITING_SLIP = 1


async def upgrade_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏û‡∏•‡∏ô subscription"""
    user = get_user_by_telegram_id(str(update.effective_user.id))
    if not user:
        await update.message.reply_text("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ /login ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô")
        return ConversationHandler.END

    # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏™‡∏î‡∏á‡πÅ‡∏û‡∏•‡∏ô
    text = "üíé *‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Premium*\n\n"
    text += "‡∏™‡∏¥‡∏ó‡∏ò‡∏¥‡∏õ‡∏£‡∏∞‡πÇ‡∏¢‡∏ä‡∏ô‡πå:\n"
    text += "‚úÖ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏î‡∏±‡∏ô‡πÑ‡∏î‡πâ‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î\n"
    text += "‚úÖ ‡∏î‡∏π‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î\n"
    text += "‚úÖ Export ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÑ‡∏°‡πà‡∏à‡∏≥‡∏Å‡∏±‡∏î\n\n"
    text += "üìã *‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏û‡∏•‡∏ô:*\n"

    keyboard = []
    for plan_type, plan in SUBSCRIPTION_PLANS.items():
        keyboard.append([
            InlineKeyboardButton(
                f"{plan['name']} - {plan['price']:.0f} ‡∏ö‡∏≤‡∏ó",
                callback_data=f"pay_{plan_type}"
            )
        ])
    keyboard.append([InlineKeyboardButton("‚ùå ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å", callback_data="pay_cancel")])

    await update.message.reply_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return WAITING_SLIP


async def plan_selected(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏û‡∏•‡∏ô - ‡πÅ‡∏™‡∏î‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô"""
    query = update.callback_query
    await query.answer()

    if query.data == "pay_cancel":
        await query.edit_message_text("‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î")
        return ConversationHandler.END

    plan_type = query.data.replace("pay_", "")
    plan = SUBSCRIPTION_PLANS.get(plan_type)

    if not plan:
        await query.edit_message_text("‡πÅ‡∏û‡∏•‡∏ô‡πÑ‡∏°‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á")
        return ConversationHandler.END

    context.user_data["selected_plan"] = plan_type

    text = f"üìù *‡πÅ‡∏û‡∏•‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å:* {plan['name']}\n"
    text += f"üí∞ *‡∏£‡∏≤‡∏Ñ‡∏≤:* {plan['price']:.0f} ‡∏ö‡∏≤‡∏ó\n\n"
    text += "üè¶ *‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏°‡∏≤‡∏ó‡∏µ‡πà:*\n"
    text += f"‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£: {PAYMENT_ACCOUNT['bank']}\n"
    text += f"‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: {PAYMENT_ACCOUNT['account_number']}\n"
    text += f"‡∏ä‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: {PAYMENT_ACCOUNT['account_name']}\n\n"
    text += f"‚ö†Ô∏è *‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏à‡∏≥‡∏ô‡∏ß‡∏ô {plan['price']:.0f} ‡∏ö‡∏≤‡∏ó ‡πÅ‡∏•‡πâ‡∏ß‡∏™‡πà‡∏á‡∏£‡∏π‡∏õ‡∏™‡∏•‡∏¥‡∏õ‡∏°‡∏≤‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà*\n"
    text += "(‡∏û‡∏¥‡∏°‡∏û‡πå /cancel ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å)"

    await query.edit_message_text(text, parse_mode="Markdown")
    return WAITING_SLIP


async def receive_slip(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """‡∏£‡∏±‡∏ö‡∏£‡∏π‡∏õ‡∏™‡∏•‡∏¥‡∏õ‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö"""
    user = get_user_by_telegram_id(str(update.effective_user.id))
    if not user:
        await update.message.reply_text("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ /login ‡∏Å‡πà‡∏≠‡∏ô")
        return ConversationHandler.END

    plan_type = context.user_data.get("selected_plan")
    if not plan_type:
        await update.message.reply_text("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏û‡∏•‡∏ô‡∏Å‡πà‡∏≠‡∏ô /upgrade")
        return ConversationHandler.END

    # ‡πÅ‡∏à‡πâ‡∏á‡∏ß‡πà‡∏≤‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö
    checking_msg = await update.message.reply_text("üîÑ ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ...")

    try:
        # Download photo
        photo = update.message.photo[-1]  # Largest size
        file = await photo.get_file()
        image_bytes = await file.download_as_bytearray()

        # Verify with SlipOK
        result = verify_slip_payment(user.id, bytes(image_bytes), plan_type)

        if result["success"]:
            text = "‚úÖ *‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à!*\n\n"
            text += f"‡πÅ‡∏û‡∏•‡∏ô: {SUBSCRIPTION_PLANS[plan_type]['name']}\n"
            text += f"‡∏¢‡∏≠‡∏î: {result['amount']:.0f} ‡∏ö‡∏≤‡∏ó\n"
            text += f"‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏: {result['expires_at']}\n\n"
            text += "üéâ ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏õ‡πá‡∏ô Premium ‡πÅ‡∏•‡πâ‡∏ß!"

            await checking_msg.edit_text(text, parse_mode="Markdown")
        else:
            await checking_msg.edit_text(f"‚ùå {result['error']}")
            return WAITING_SLIP  # ‡πÉ‡∏´‡πâ‡∏™‡πà‡∏á‡∏™‡∏•‡∏¥‡∏õ‡πÉ‡∏´‡∏°‡πà‡πÑ‡∏î‡πâ

    except Exception as e:
        logger.error(f"Slip verification error: {e}")
        await checking_msg.edit_text("‚ùå ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏≠‡∏á‡πÉ‡∏´‡∏°‡πà")
        return WAITING_SLIP

    context.user_data.clear()
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô"""
    context.user_data.clear()
    await update.message.reply_text("‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô")
    return ConversationHandler.END


async def subscription_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """‡∏î‡∏π‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ subscription"""
    user = get_user_by_telegram_id(str(update.effective_user.id))
    if not user:
        await update.message.reply_text("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤ /login ‡∏Å‡πà‡∏≠‡∏ô")
        return

    status = get_subscription_status(user.id)

    if status["is_active"]:
        text = "üíé *Premium Member*\n\n"
        text += f"‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏: {status['expires_at']}\n"
        text += f"‡πÄ‡∏´‡∏•‡∏∑‡∏≠‡∏≠‡∏µ‡∏Å: {status['days_remaining']} ‡∏ß‡∏±‡∏ô"
    else:
        text = "üì¶ *Free Member*\n\n"
        text += "‡∏à‡∏≥‡∏Å‡∏±‡∏î 30 ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£\n"
        text += "‡∏û‡∏¥‡∏°‡∏û‡πå /upgrade ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î"

    await update.message.reply_text(text, parse_mode="Markdown")


def get_payment_handler():
    """‡∏™‡∏£‡πâ‡∏≤‡∏á ConversationHandler ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö payment"""
    return ConversationHandler(
        entry_points=[CommandHandler("upgrade", upgrade_command)],
        states={
            WAITING_SLIP: [
                CallbackQueryHandler(plan_selected, pattern="^pay_"),
                MessageHandler(filters.PHOTO, receive_slip),
            ],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
        allow_reentry=True
    )
```

### 5.2 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: `app/bot/services.py`
```python
# ‡πÄ‡∏û‡∏¥‡πà‡∏° functions
def verify_slip_payment(user_id: int, image_bytes: bytes, plan_type: str) -> dict:
    """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏•‡∏¥‡∏õ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î subscription"""
    # Logic ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÉ‡∏ô payment router
    pass

def get_subscription_status(user_id: int) -> dict:
    """‡∏î‡∏∂‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ subscription"""
    pass
```

### 5.3 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: `app/bot/main.py`
```python
# ‡πÄ‡∏û‡∏¥‡πà‡∏° import
from .handlers.payment import get_payment_handler, subscription_command

# ‡πÄ‡∏û‡∏¥‡πà‡∏° handlers
application.add_handler(get_payment_handler())
application.add_handler(CommandHandler("subscription", subscription_command))
```

---

## 6. Web Frontend Implementation

### 6.1 ‡πÑ‡∏ü‡∏•‡πå‡πÉ‡∏´‡∏°‡πà: `frontend/app/(dashboard)/subscription/page.tsx`
```tsx
"use client";

import { useEffect, useState } from "react";
import { useRouter } from "next/navigation";
import { CreditCard, Crown, Upload, Check, Loader2, ArrowLeft } from "lucide-react";
import api from "@/lib/api";
import { toast } from "sonner";

import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";

interface Plan {
    plan_type: string;
    name: string;
    name_en: string;
    price: number;
    duration_days: number;
    features: string[];
}

export default function SubscriptionPage() {
    const router = useRouter();
    const [loading, setLoading] = useState(true);
    const [plans, setPlans] = useState<Plan[]>([]);
    const [paymentAccount, setPaymentAccount] = useState<any>(null);
    const [currentTier, setCurrentTier] = useState("free");
    const [expiresAt, setExpiresAt] = useState<string | null>(null);

    const [selectedPlan, setSelectedPlan] = useState<string | null>(null);
    const [slipFile, setSlipFile] = useState<File | null>(null);
    const [isUploading, setIsUploading] = useState(false);

    useEffect(() => {
        fetchPlans();
    }, []);

    const fetchPlans = async () => {
        try {
            const res = await api.get("/payment/plans");
            const data = res.data.data;
            setPlans(data.plans);
            setPaymentAccount(data.payment_account);
            setCurrentTier(data.current_tier);
            setExpiresAt(data.expires_at);
        } catch (error) {
            toast.error("Failed to load subscription plans");
        } finally {
            setLoading(false);
        }
    };

    const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
        if (e.target.files && e.target.files[0]) {
            setSlipFile(e.target.files[0]);
        }
    };

    const handleSubmit = async () => {
        if (!selectedPlan || !slipFile) {
            toast.error("‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÅ‡∏û‡∏•‡∏ô‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏•‡∏¥‡∏õ");
            return;
        }

        setIsUploading(true);

        const formData = new FormData();
        formData.append("plan_type", selectedPlan);
        formData.append("file", slipFile);

        try {
            const res = await api.post("/payment/verify-slip", formData, {
                headers: { "Content-Type": "multipart/form-data" }
            });

            toast.success(res.data.message);
            setCurrentTier("premium");
            setExpiresAt(res.data.data.subscription_expires_at);
            setSelectedPlan(null);
            setSlipFile(null);

        } catch (error: any) {
            toast.error(error.response?.data?.detail || "‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à");
        } finally {
            setIsUploading(false);
        }
    };

    if (loading) {
        return <div className="p-8 flex items-center justify-center">Loading...</div>;
    }

    return (
        <div className="p-6 md:p-8 space-y-8 min-h-screen bg-slate-50 dark:bg-slate-950">
            {/* Header */}
            <div className="flex items-center gap-4">
                <Button variant="ghost" size="icon" onClick={() => router.push('/dashboard')}>
                    <ArrowLeft className="h-4 w-4" />
                </Button>
                <div>
                    <h1 className="text-3xl font-bold tracking-tight">Subscription</h1>
                    <p className="text-slate-500">‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Premium ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÄ‡∏ï‡πá‡∏°‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö</p>
                </div>
            </div>

            {/* Current Status */}
            <Card>
                <CardHeader>
                    <CardTitle className="flex items-center gap-2">
                        <Crown className="h-5 w-5" />
                        ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
                    </CardTitle>
                </CardHeader>
                <CardContent>
                    <div className="flex items-center gap-4">
                        <Badge variant={currentTier === "premium" ? "default" : "secondary"}>
                            {currentTier === "premium" ? "Premium" : "Free"}
                        </Badge>
                        {expiresAt && (
                            <span className="text-sm text-slate-500">
                                ‡∏´‡∏°‡∏î‡∏≠‡∏≤‡∏¢‡∏∏: {new Date(expiresAt).toLocaleDateString('th-TH')}
                            </span>
                        )}
                    </div>
                </CardContent>
            </Card>

            {/* Plans */}
            <div className="grid md:grid-cols-2 gap-6">
                {plans.map((plan) => (
                    <Card
                        key={plan.plan_type}
                        className={`cursor-pointer transition-all ${
                            selectedPlan === plan.plan_type
                                ? "ring-2 ring-primary"
                                : "hover:shadow-lg"
                        }`}
                        onClick={() => setSelectedPlan(plan.plan_type)}
                    >
                        <CardHeader>
                            <CardTitle>{plan.name}</CardTitle>
                            <CardDescription>{plan.name_en}</CardDescription>
                        </CardHeader>
                        <CardContent>
                            <div className="text-3xl font-bold mb-4">
                                ‡∏ø{plan.price}
                                <span className="text-sm font-normal text-slate-500">
                                    /{plan.duration_days} ‡∏ß‡∏±‡∏ô
                                </span>
                            </div>
                            <ul className="space-y-2">
                                {plan.features.map((feature, i) => (
                                    <li key={i} className="flex items-center gap-2">
                                        <Check className="h-4 w-4 text-green-500" />
                                        <span className="text-sm">{feature}</span>
                                    </li>
                                ))}
                            </ul>
                        </CardContent>
                    </Card>
                ))}
            </div>

            {/* Payment Form */}
            {selectedPlan && (
                <Card>
                    <CardHeader>
                        <CardTitle className="flex items-center gap-2">
                            <CreditCard className="h-5 w-5" />
                            ‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô
                        </CardTitle>
                    </CardHeader>
                    <CardContent className="space-y-4">
                        <div className="p-4 bg-blue-50 rounded-lg">
                            <p className="font-medium">‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô‡∏°‡∏≤‡∏ó‡∏µ‡πà:</p>
                            <p>‡∏ò‡∏ô‡∏≤‡∏Ñ‡∏≤‡∏£: {paymentAccount?.bank}</p>
                            <p>‡πÄ‡∏•‡∏Ç‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: {paymentAccount?.account_number}</p>
                            <p>‡∏ä‡∏∑‡πà‡∏≠‡∏ö‡∏±‡∏ç‡∏ä‡∏µ: {paymentAccount?.account_name}</p>
                            <p className="mt-2 text-lg font-bold">
                                ‡∏¢‡∏≠‡∏î: ‡∏ø{plans.find(p => p.plan_type === selectedPlan)?.price}
                            </p>
                        </div>

                        <div>
                            <label className="block text-sm font-medium mb-2">
                                ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏™‡∏•‡∏¥‡∏õ‡∏Å‡∏≤‡∏£‡πÇ‡∏≠‡∏ô‡πÄ‡∏á‡∏¥‡∏ô
                            </label>
                            <Input
                                type="file"
                                accept="image/*"
                                onChange={handleFileChange}
                            />
                        </div>
                    </CardContent>
                    <CardFooter>
                        <Button
                            onClick={handleSubmit}
                            disabled={!slipFile || isUploading}
                            className="w-full"
                        >
                            {isUploading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
                            {isUploading ? "‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö..." : "‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏ä‡∏≥‡∏£‡∏∞‡πÄ‡∏á‡∏¥‡∏ô"}
                        </Button>
                    </CardFooter>
                </Card>
            )}
        </div>
    );
}
```

### 6.2 ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç: `frontend/app/(dashboard)/settings/page.tsx`
```tsx
// ‡πÄ‡∏û‡∏¥‡πà‡∏° Tab "Subscription" ‡∏´‡∏£‡∏∑‡∏≠ Link ‡πÑ‡∏õ‡∏´‡∏ô‡πâ‡∏≤ subscription
<TabsTrigger value="subscription">Subscription</TabsTrigger>

// ‡∏´‡∏£‡∏∑‡∏≠‡πÄ‡∏û‡∏¥‡πà‡∏° Card link
<Card className="cursor-pointer hover:shadow-lg" onClick={() => router.push('/subscription')}>
    <CardHeader>
        <CardTitle>Subscription</CardTitle>
        <CardDescription>‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏û‡∏•‡∏ô‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏û‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Premium</CardDescription>
    </CardHeader>
</Card>
```

---

## 7. Implementation Checklist

### Phase 1: Backend Core
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á `app/config/pricing.py`
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á `app/services/slipok.py`
- [ ] ‡πÄ‡∏û‡∏¥‡πà‡∏° Payment model ‡πÉ‡∏ô `app/models.py`
- [ ] ‡πÄ‡∏û‡∏¥‡πà‡∏° schemas ‡πÉ‡∏ô `app/schemas.py`
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á `app/routers/payment.py`
- [ ] ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç `app/main.py` include router
- [ ] Test API endpoints

### Phase 2: Telegram Bot
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á `app/bot/handlers/payment.py`
- [ ] ‡πÄ‡∏û‡∏¥‡πà‡∏° functions ‡πÉ‡∏ô `app/bot/services.py`
- [ ] ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç `app/bot/main.py`
- [ ] Test bot commands

### Phase 3: Web Frontend
- [ ] ‡∏™‡∏£‡πâ‡∏≤‡∏á `frontend/app/(dashboard)/subscription/page.tsx`
- [ ] ‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç settings page ‡πÄ‡∏û‡∏¥‡πà‡∏° link
- [ ] Test web payment flow

### Phase 4: Configuration
- [ ] ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ `SLIPOK_API_KEY` ‡πÉ‡∏ô .env
- [ ] ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ `SLIPOK_BRANCH_ID` ‡πÉ‡∏ô .env
- [ ] ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ö‡∏±‡∏ç‡∏ä‡∏µ‡∏£‡∏±‡∏ö‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô pricing.py

---

## 8. Security Checklist
- [ ] Rate limiting (5/min) ‡∏ö‡∏ô verify-slip endpoint
- [ ] ‡πÉ‡∏ä‡πâ `log:true` ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏™‡∏•‡∏¥‡∏õ‡∏ã‡πâ‡∏≥‡∏ù‡∏±‡πà‡∏á SlipOK
- [ ] ‡πÄ‡∏Å‡πá‡∏ö trans_ref_hash ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏ã‡πâ‡∏≥‡πÉ‡∏ô‡∏ê‡∏≤‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
- [ ] Encrypt sender name (PII protection)
- [ ] Validate file type ‡πÅ‡∏•‡∏∞ size
- [ ] Log ‡∏ó‡∏∏‡∏Å payment attempt
